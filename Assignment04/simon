module Dictionary
   type Dictionary =
      | Node of char * Dictionary list * bool
      | Root of Dictionary list
   
   let empty s = Root([])
   
   let charExists c =
      fun node ->
      match node with
         | Root(_) -> false
         | Node(v, _, _) -> v = c
   
   let rec insertChars (chars: char list) = function
      | Root(list) ->
       if List.exists(charExists chars.Head) list = false
          then Root(list @ [(Node(chars.Head, [], false) |> insertChars chars)])
       else Root(List.map (fun node -> insertChars chars node) list)
      | Node(c, list, isword) when c = chars.Head ->
       if chars.Tail = []
          then Node(c, list, true)
       else if list = []
          then Node(c, [(Node(chars.Tail.Head, [], false) |> insertChars chars.Tail)], isword)
       else if List.exists(charExists chars.Tail.Head) list = false
          then Node(c, list @ [(Node(chars.Tail.Head, [], false) |> insertChars chars.Tail)], isword)
       else Node (c, List.map (fun node -> insertChars chars.Tail node) list, isword)
      | Node(c, list, isword) -> Node(c, list, isword)
   
   let insert (word: string) =
      let wordChars = [for character in word -> character]
      insertChars wordChars
   
   let lookup (word: string) (tree: Dictionary) =
      let wordChars = [for character in word -> character]
       
      let rec find (chars: char list) = function
         | Root(list) ->
            if list = []
               then false
            else list |> List.exists (fun node -> find chars node)
         | Node(c, list, isword)
            when c = chars.Head -> if chars.Tail = [] 
                                      then isword
                                   else if list = [] 
                                      then false
                                   else list |> List.exists (fun node -> find chars.Tail node)
         | Node(c, list, isword) -> false
       
      find wordChars tree